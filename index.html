<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laser Maze Puzzle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            color: white;
        }
        
        .game-container {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            width: 100%;
            max-width: 1000px;
            overflow: hidden;
        }
        
        .game-header {
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #00a8ff;
        }
        
        .game-title {
            font-size: 24px;
            font-weight: bold;
            color: #00a8ff;
            text-shadow: 0 0 10px rgba(0, 168, 255, 0.7);
        }
        
        .game-stats {
            display: flex;
            gap: 20px;
        }
        
        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #ffcc00;
        }
        
        .stat-label {
            font-size: 12px;
            color: #aaa;
        }
        
        .game-content {
            display: flex;
            padding: 20px;
            gap: 20px;
        }
        
        .game-board {
            flex: 1;
            background: rgba(30, 30, 60, 0.8);
            border-radius: 10px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .board-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .level-title {
            font-size: 20px;
            color: #ffcc00;
        }
        
        .objective {
            font-size: 14px;
            color: #aaa;
        }
        
        .board-container {
            position: relative;
            background: rgba(20, 20, 40, 0.9);
            border-radius: 8px;
            overflow: hidden;
            aspect-ratio: 1;
        }
        
        #game-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .game-controls {
            width: 280px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .control-panel {
            background: rgba(30, 30, 60, 0.8);
            border-radius: 10px;
            padding: 15px;
        }
        
        .panel-title {
            font-size: 18px;
            color: #00a8ff;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .object-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .object-option {
            padding: 10px;
            background: rgba(50, 50, 100, 0.8);
            border-radius: 5px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        
        .object-option:hover {
            background: rgba(70, 70, 120, 0.8);
        }
        
        .object-option.active {
            background: rgba(0, 168, 255, 0.5);
            box-shadow: 0 0 10px rgba(0, 168, 255, 0.7);
        }
        
        .object-icon {
            font-size: 20px;
            font-weight: bold;
        }
        
        .instructions {
            font-size: 14px;
            line-height: 1.5;
            color: #ccc;
        }
        
        .instructions ul {
            padding-left: 20px;
            margin: 10px 0;
        }
        
        .instructions li {
            margin-bottom: 5px;
        }
        
        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }
        
        .btn-primary {
            background: #00a8ff;
            color: white;
        }
        
        .btn-primary:hover {
            background: #0090e0;
            box-shadow: 0 0 15px rgba(0, 168, 255, 0.7);
        }
        
        .btn-secondary {
            background: #ffcc00;
            color: #333;
        }
        
        .btn-secondary:hover {
            background: #e6b800;
            box-shadow: 0 0 15px rgba(255, 204, 0, 0.7);
        }
        
        .btn-reset {
            background: #ff3333;
            color: white;
        }
        
        .btn-reset:hover {
            background: #e60000;
            box-shadow: 0 0 15px rgba(255, 51, 51, 0.7);
        }
        
        .level-complete {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }
        
        .level-complete.show {
            opacity: 1;
            pointer-events: all;
        }
        
        .complete-message {
            font-size: 36px;
            color: #ffcc00;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(255, 204, 0, 0.7);
        }
        
        .complete-stats {
            font-size: 20px;
            margin-bottom: 30px;
            text-align: center;
        }
        
        .controls-row {
            display: flex;
            gap: 10px;
        }
        
        .drag-instruction {
            text-align: center;
            font-size: 14px;
            color: #ffcc00;
            margin-top: 10px;
        }
        
        .level-indicator {
            display: flex;
            justify-content: center;
            gap: 5px;
            margin-top: 10px;
        }
        
        .level-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            cursor: pointer;
        }
        
        .level-dot.active {
            background: #ffcc00;
            box-shadow: 0 0 5px #ffcc00;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <div class="game-title">LASER MAZE PUZZLE</div>
            <div class="game-stats">
                <div class="stat">
                    <div class="stat-value" id="level-display">1</div>
                    <div class="stat-label">LEVEL</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="targets-display">0/0</div>
                    <div class="stat-label">TARGETS</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="moves-display">0</div>
                    <div class="stat-label">MOVES</div>
                </div>
            </div>
        </div>
        
        <div class="game-content">
            <div class="game-board">
                <div class="board-header">
                    <div class="level-title">Level <span id="level-title">1</span></div>
                    <div class="objective">Guide the laser to hit all targets</div>
                </div>
                
                <div class="board-container">
                    <canvas id="game-canvas"></canvas>
                    <div class="level-complete" id="level-complete">
                        <div class="complete-message">LEVEL COMPLETE!</div>
                        <div class="complete-stats">
                            <div>Targets hit: <span id="targets-hit">0</span>/<span id="targets-total">0</span></div>
                            <div>Moves used: <span id="moves-used">0</span></div>
                        </div>
                        <div class="controls-row">
                            <button class="btn btn-secondary" id="next-level">NEXT LEVEL</button>
                            <button class="btn btn-reset" id="play-again">PLAY AGAIN</button>
                        </div>
                    </div>
                </div>
                
                <div class="drag-instruction">Drag objects to change the laser path. Right-click to rotate.</div>
                <div class="level-indicator" id="level-indicator">
                    <!-- Level dots will be generated by JavaScript -->
                </div>
            </div>
            
            <div class="game-controls">
                <div class="control-panel">
                    <div class="panel-title">LASER CONTROL</div>
                    <button class="btn btn-primary" id="step-laser" style="width: 100%; margin-bottom: 10px;">FIRE LASER</button>
                    <button class="btn btn-secondary" id="auto-laser" style="width: 100%;">AUTO LASER (ON)</button>
                </div>
                
                <div class="control-panel">
                    <div class="panel-title">OBJECTS</div>
                    <div class="object-selector">
                        <div class="object-option active" data-type="mirror-forward">
                            <div class="object-icon">/</div>
                            <div>Forward Mirror</div>
                        </div>
                        <div class="object-option" data-type="mirror-backward">
                            <div class="object-icon">\</div>
                            <div>Backward Mirror</div>
                        </div>
                        <div class="object-option" data-type="splitter">
                            <div class="object-icon">+</div>
                            <div>Beam Splitter</div>
                        </div>
                        <div class="object-option" data-type="blocker">
                            <div class="object-icon">■</div>
                            <div>Blocker</div>
                        </div>
                    </div>
                    <div class="instructions">
                        <p><strong>How to Play:</strong></p>
                        <ul>
                            <li>Drag objects to empty cells</li>
                            <li>Right-click objects to rotate them</li>
                            <li>Click "FIRE LASER" to test your solution</li>
                            <li>Hit all targets to complete the level</li>
                            <li>Use splitters to hit multiple targets</li>
                        </ul>
                    </div>
                </div>
                
                <div class="control-panel">
                    <div class="panel-title">CONTROLS</div>
                    <button class="btn btn-secondary" id="reset-level" style="width: 100%; margin-bottom: 10px;">RESET LEVEL</button>
                    <div class="controls-row">
                        <button class="btn btn-secondary" id="prev-level">PREV</button>
                        <button class="btn btn-secondary" id="next-level-btn">NEXT</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Game state
            const gameState = {
                currentLevel: 1,
                levels: [
                    {
                        // Level 1 - Basic mirror reflection
                        name: "Getting Started",
                        lasers: [{ x: 0, y: 3, direction: 'right' }],
                        targets: [{ x: 6, y: 3 }],
                        objects: [
                            { x: 3, y: 3, type: 'mirror-forward', movable: true }
                        ],
                        gridSize: 7
                    },
                    {
                        // Level 2 - Two mirrors
                        name: "Double Reflection",
                        lasers: [{ x: 0, y: 1, direction: 'right' }],
                        targets: [{ x: 6, y: 5 }],
                        objects: [
                            { x: 2, y: 1, type: 'mirror-forward', movable: true },
                            { x: 4, y: 3, type: 'mirror-backward', movable: true }
                        ],
                        gridSize: 7
                    },
                    {
                        // Level 3 - Beam splitter introduction
                        name: "Beam Division",
                        lasers: [{ x: 0, y: 3, direction: 'right' }],
                        targets: [{ x: 6, y: 1 }, { x: 6, y: 5 }],
                        objects: [
                            { x: 3, y: 3, type: 'splitter', movable: true }
                        ],
                        gridSize: 7
                    },
                    {
                        // Level 4 - Blockers and mirrors
                        name: "Obstacle Course",
                        lasers: [{ x: 0, y: 3, direction: 'right' }],
                        targets: [{ x: 6, y: 3 }],
                        objects: [
                            { x: 2, y: 2, type: 'blocker', movable: false },
                            { x: 2, y: 4, type: 'blocker', movable: false },
                            { x: 4, y: 2, type: 'mirror-forward', movable: true },
                            { x: 4, y: 4, type: 'mirror-backward', movable: true }
                        ],
                        gridSize: 7
                    },
                    {
                        // Level 5 - Complex splitter path (FIXED)
                        name: "Split Decision",
                        lasers: [
                            { x: 0, y: 3, direction: 'right' },
                            { x: 6, y: 3, direction: 'left' }
                        ],
                        targets: [
                            { x: 0, y: 6 }, 
                            { x: 3, y: 6 }, 
                            { x: 6, y: 6 },
                            { x: 3, y: 0 }
                        ],
                        objects: [
                            { x: 2, y: 2, type: 'mirror-forward', movable: true },
                            { x: 4, y: 2, type: 'mirror-backward', movable: true },
                            { x: 2, y: 4, type: 'splitter', movable: true },
                            { x: 4, y: 4, type: 'splitter', movable: true }
                        ],
                        blockers: [
                            { x: 1, y: 1 }, { x: 5, y: 1 }
                        ],
                        gridSize: 7
                    },
                    {
                        // Level 6 - Multiple lasers
                        name: "Dual Beams",
                        lasers: [
                            { x: 0, y: 1, direction: 'right' },
                            { x: 0, y: 5, direction: 'right' }
                        ],
                        targets: [
                            { x: 6, y: 1 }, 
                            { x: 6, y: 5 },
                            { x: 3, y: 3 }
                        ],
                        objects: [
                            { x: 2, y: 1, type: 'mirror-forward', movable: true },
                            { x: 2, y: 5, type: 'mirror-backward', movable: true },
                            { x: 4, y: 3, type: 'splitter', movable: true }
                        ],
                        blockers: [
                            { x: 3, y: 1 }, { x: 3, y: 5 }
                        ],
                        gridSize: 7
                    },
                    {
                        // Level 7 - Advanced splitter network
                        name: "Splitter Network",
                        lasers: [{ x: 3, y: 0, direction: 'down' }],
                        targets: [
                            { x: 0, y: 3 }, 
                            { x: 3, y: 6 },
                            { x: 6, y: 3 },
                            { x: 0, y: 6 },
                            { x: 6, y: 6 }
                        ],
                        objects: [
                            { x: 1, y: 2, type: 'mirror-forward', movable: true },
                            { x: 5, y: 2, type: 'mirror-backward', movable: true },
                            { x: 3, y: 3, type: 'splitter', movable: true },
                            { x: 1, y: 4, type: 'splitter', movable: true },
                            { x: 5, y: 4, type: 'splitter', movable: true }
                        ],
                        blockers: [
                            { x: 2, y: 2 }, { x: 4, y: 2 }, { x: 2, y: 4 }, { x: 4, y: 4 }
                        ],
                        gridSize: 7
                    },
                    {
                        // Level 8 - Complex maze
                        name: "Laser Maze",
                        lasers: [{ x: 0, y: 0, direction: 'right' }],
                        targets: [
                            { x: 6, y: 0 }, 
                            { x: 6, y: 6 },
                            { x: 0, y: 6 }
                        ],
                        objects: [
                            { x: 2, y: 0, type: 'mirror-forward', movable: true },
                            { x: 4, y: 0, type: 'mirror-backward', movable: true },
                            { x: 6, y: 2, type: 'mirror-forward', movable: true },
                            { x: 4, y: 4, type: 'splitter', movable: true },
                            { x: 2, y: 6, type: 'mirror-backward', movable: true },
                            { x: 0, y: 4, type: 'splitter', movable: true }
                        ],
                        blockers: [
                            { x: 1, y: 1 }, { x: 3, y: 1 }, { x: 5, y: 1 },
                            { x: 1, y: 3 }, { x: 3, y: 3 }, { x: 5, y: 3 },
                            { x: 1, y: 5 }, { x: 3, y: 5 }, { x: 5, y: 5 }
                        ],
                        gridSize: 7
                    },
                    {
                        // Level 9 - Ultimate challenge
                        name: "Master Challenge",
                        lasers: [
                            { x: 0, y: 0, direction: 'right' },
                            { x: 6, y: 0, direction: 'down' },
                            { x: 6, y: 6, direction: 'left' },
                            { x: 0, y: 6, direction: 'up' }
                        ],
                        targets: [
                            { x: 2, y: 2 }, 
                            { x: 4, y: 2 },
                            { x: 2, y: 4 },
                            { x: 4, y: 4 },
                            { x: 3, y: 3 }
                        ],
                        objects: [
                            { x: 1, y: 1, type: 'mirror-forward', movable: true },
                            { x: 5, y: 1, type: 'mirror-backward', movable: true },
                            { x: 1, y: 5, type: 'mirror-backward', movable: true },
                            { x: 5, y: 5, type: 'mirror-forward', movable: true },
                            { x: 3, y: 1, type: 'splitter', movable: true },
                            { x: 3, y: 5, type: 'splitter', movable: true },
                            { x: 1, y: 3, type: 'splitter', movable: true },
                            { x: 5, y: 3, type: 'splitter', movable: true }
                        ],
                        blockers: [
                            { x: 0, y: 3 }, { x: 6, y: 3 }, { x: 3, y: 0 }, { x: 3, y: 6 }
                        ],
                        gridSize: 7
                    },
                    {
                        // Level 10 - Final boss level
                        name: "The Grand Finale",
                        lasers: [
                            { x: 1, y: 0, direction: 'down' },
                            { x: 5, y: 0, direction: 'down' },
                            { x: 0, y: 3, direction: 'right' },
                            { x: 6, y: 3, direction: 'left' }
                        ],
                        targets: [
                            { x: 0, y: 0 }, 
                            { x: 6, y: 0 },
                            { x: 0, y: 6 },
                            { x: 6, y: 6 },
                            { x: 3, y: 3 },
                            { x: 1, y: 1 },
                            { x: 5, y: 1 },
                            { x: 1, y: 5 },
                            { x: 5, y: 5 }
                        ],
                        objects: [
                            { x: 2, y: 1, type: 'mirror-forward', movable: true },
                            { x: 4, y: 1, type: 'mirror-backward', movable: true },
                            { x: 2, y: 5, type: 'mirror-backward', movable: true },
                            { x: 4, y: 5, type: 'mirror-forward', movable: true },
                            { x: 1, y: 2, type: 'splitter', movable: true },
                            { x: 5, y: 2, type: 'splitter', movable: true },
                            { x: 1, y: 4, type: 'splitter', movable: true },
                            { x: 5, y: 4, type: 'splitter', movable: true },
                            { x: 3, y: 1, type: 'blocker', movable: false },
                            { x: 3, y: 5, type: 'blocker', movable: false }
                        ],
                        gridSize: 7
                    }
                ],
                moves: 0,
                selectedObjectType: 'mirror-forward',
                autoLaser: true,
                draggedObject: null,
                cellSize: 0,
                hitTargets: new Set()
            };

            // DOM elements
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            const levelDisplay = document.getElementById('level-display');
            const targetsDisplay = document.getElementById('targets-display');
            const movesDisplay = document.getElementById('moves-display');
            const levelTitle = document.getElementById('level-title');
            const stepLaserBtn = document.getElementById('step-laser');
            const autoLaserBtn = document.getElementById('auto-laser');
            const resetLevelBtn = document.getElementById('reset-level');
            const prevLevelBtn = document.getElementById('prev-level');
            const nextLevelBtn = document.getElementById('next-level-btn');
            const levelComplete = document.getElementById('level-complete');
            const nextLevelCompleteBtn = document.getElementById('next-level');
            const playAgainBtn = document.getElementById('play-again');
            const targetsHit = document.getElementById('targets-hit');
            const targetsTotal = document.getElementById('targets-total');
            const movesUsed = document.getElementById('moves-used');
            const objectOptions = document.querySelectorAll('.object-option');
            const levelIndicator = document.getElementById('level-indicator');

            // Initialize the game
            function initGame() {
                setupCanvas();
                createLevelIndicator();
                setupEventListeners();
                renderGame();
                if (gameState.autoLaser) {
                    calculateAndDrawLasers();
                }
                updateDisplay();
            }

            // Set up canvas
            function setupCanvas() {
                const container = document.querySelector('.board-container');
                const size = Math.min(container.clientWidth, container.clientHeight);
                canvas.width = size;
                canvas.height = size;
                gameState.cellSize = size / gameState.levels[gameState.currentLevel - 1].gridSize;
            }

            // Create level indicator dots
            function createLevelIndicator() {
                levelIndicator.innerHTML = '';
                for (let i = 0; i < gameState.levels.length; i++) {
                    const dot = document.createElement('div');
                    dot.className = `level-dot ${i + 1 === gameState.currentLevel ? 'active' : ''}`;
                    dot.addEventListener('click', () => {
                        gameState.currentLevel = i + 1;
                        gameState.moves = 0;
                        gameState.hitTargets.clear();
                        setupCanvas();
                        renderGame();
                        if (gameState.autoLaser) {
                            calculateAndDrawLasers();
                        }
                        updateDisplay();
                    });
                    levelIndicator.appendChild(dot);
                }
            }

            // Render the game
            function renderGame() {
                const level = gameState.levels[gameState.currentLevel - 1];
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw grid
                drawGrid();
                
                // Draw objects
                drawObjects();
                
                // Draw targets
                drawTargets();
                
                // Draw lasers
                drawLasers();
            }

            // Draw grid
            function drawGrid() {
                const level = gameState.levels[gameState.currentLevel - 1];
                const size = gameState.cellSize;
                
                ctx.strokeStyle = 'rgba(100, 100, 150, 0.5)';
                ctx.lineWidth = 1;
                
                for (let i = 0; i <= level.gridSize; i++) {
                    // Vertical lines
                    ctx.beginPath();
                    ctx.moveTo(i * size, 0);
                    ctx.lineTo(i * size, canvas.height);
                    ctx.stroke();
                    
                    // Horizontal lines
                    ctx.beginPath();
                    ctx.moveTo(0, i * size);
                    ctx.lineTo(canvas.width, i * size);
                    ctx.stroke();
                }
            }

            // Draw objects
            function drawObjects() {
                const level = gameState.levels[gameState.currentLevel - 1];
                const size = gameState.cellSize;
                
                // Draw blockers first (background objects)
                level.objects.forEach(obj => {
                    if (obj.type === 'blocker') {
                        drawBlocker(obj, size);
                    }
                });
                
                // Draw other objects
                level.objects.forEach(obj => {
                    if (obj.type !== 'blocker') {
                        drawInteractiveObject(obj, size);
                    }
                });
            }

            // Draw blocker
            function drawBlocker(obj, size) {
                const x = obj.x * size;
                const y = obj.y * size;
                
                // Blocker background
                ctx.fillStyle = 'rgba(80, 80, 120, 0.9)';
                ctx.fillRect(x, y, size, size);
                
                // Blocker border
                ctx.strokeStyle = 'rgba(60, 60, 100, 0.9)';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, size, size);
                
                // Blocker X
                ctx.strokeStyle = 'rgba(40, 40, 80, 0.9)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x + 5, y + 5);
                ctx.lineTo(x + size - 5, y + size - 5);
                ctx.moveTo(x + size - 5, y + 5);
                ctx.lineTo(x + 5, y + size - 5);
                ctx.stroke();
            }

            // Draw interactive object (mirror or splitter)
            function drawInteractiveObject(obj, size) {
                const x = obj.x * size;
                const y = obj.y * size;
                
                // Object background
                ctx.fillStyle = obj.movable ? 'rgba(100, 150, 255, 0.7)' : 'rgba(150, 100, 255, 0.7)';
                ctx.fillRect(x, y, size, size);
                
                // Object border
                ctx.strokeStyle = obj.movable ? 'rgba(80, 130, 255, 0.9)' : 'rgba(130, 80, 255, 0.9)';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, size, size);
                
                // Draw object based on type
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3;
                
                switch(obj.type) {
                    case 'mirror-forward':
                        // Forward slash (/)
                        ctx.beginPath();
                        ctx.moveTo(x + size - 5, y + 5);
                        ctx.lineTo(x + 5, y + size - 5);
                        ctx.stroke();
                        break;
                        
                    case 'mirror-backward':
                        // Backward slash (\)
                        ctx.beginPath();
                        ctx.moveTo(x + 5, y + 5);
                        ctx.lineTo(x + size - 5, y + size - 5);
                        ctx.stroke();
                        break;
                        
                    case 'splitter':
                        // Beam splitter (+)
                        ctx.beginPath();
                        // Horizontal line
                        ctx.moveTo(x + 5, y + size/2);
                        ctx.lineTo(x + size - 5, y + size/2);
                        // Vertical line
                        ctx.moveTo(x + size/2, y + 5);
                        ctx.lineTo(x + size/2, y + size - 5);
                        ctx.stroke();
                        
                        // Center dot
                        ctx.beginPath();
                        ctx.arc(x + size/2, y + size/2, 3, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                }
            }

            // Draw targets
            function drawTargets() {
                const level = gameState.levels[gameState.currentLevel - 1];
                const size = gameState.cellSize;
                
                level.targets.forEach(target => {
                    const centerX = target.x * size + size / 2;
                    const centerY = target.y * size + size / 2;
                    const radius = size / 3;
                    
                    // Check if target is hit
                    const isHit = gameState.hitTargets.has(`${target.x},${target.y}`);
                    
                    // Target circle
                    const gradient = ctx.createRadialGradient(
                        centerX, centerY, radius / 2,
                        centerX, centerY, radius
                    );
                    
                    if (isHit) {
                        gradient.addColorStop(0, '#33ff33');
                        gradient.addColorStop(1, '#009900');
                    } else {
                        gradient.addColorStop(0, '#ff33aa');
                        gradient.addColorStop(1, '#aa0077');
                    }
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Target outline
                    ctx.strokeStyle = isHit ? '#00ff00' : '#ff00aa';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Target letter
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold ' + (size / 3) + 'px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('T', centerX, centerY);
                });
            }

            // Draw lasers
            function drawLasers() {
                const level = gameState.levels[gameState.currentLevel - 1];
                const size = gameState.cellSize;
                
                level.lasers.forEach(laser => {
                    const x = laser.x * size + size / 2;
                    const y = laser.y * size + size / 2;
                    
                    // Laser source
                    const gradient = ctx.createRadialGradient(x, y, size / 8, x, y, size / 3);
                    gradient.addColorStop(0, '#ff6600');
                    gradient.addColorStop(1, '#ff3300');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, size / 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Laser direction indicator
                    ctx.fillStyle = '#ff9900';
                    ctx.font = 'bold ' + (size / 4) + 'px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(laser.direction.toUpperCase(), x, y);
                });
            }

            // Calculate and draw laser paths
            function calculateAndDrawLasers() {
                const level = gameState.levels[gameState.currentLevel - 1];
                
                // Clear previous laser beams and hit targets
                gameState.hitTargets.clear();
                renderGame();
                
                // Calculate and draw each laser path
                level.lasers.forEach(laser => {
                    const paths = calculateLaserPaths(laser);
                    paths.forEach(path => {
                        drawLaserBeam(path);
                    });
                });
                
                // Check if level is complete
                if (checkLevelComplete()) {
                    targetsHit.textContent = gameState.hitTargets.size;
                    targetsTotal.textContent = level.targets.length;
                    movesUsed.textContent = gameState.moves;
                    levelComplete.classList.add('show');
                }
                
                updateDisplay();
            }

            // Calculate laser paths (handles splitters)
            function calculateLaserPaths(laser) {
                const level = gameState.levels[gameState.currentLevel - 1];
                const paths = [];
                
                // Start with the initial laser
                const queue = [{ x: laser.x, y: laser.y, direction: laser.direction, path: [] }];
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    let x = current.x;
                    let y = current.y;
                    let direction = current.direction;
                    const path = [...current.path];
                    
                    // Add starting point
                    path.push({ x, y, direction });
                    
                    // Follow the laser path
                    while (x >= 0 && x < level.gridSize && y >= 0 && y < level.gridSize) {
                        // Move to next cell
                        switch (direction) {
                            case 'right': x++; break;
                            case 'left': x--; break;
                            case 'down': y++; break;
                            case 'up': y--; break;
                        }
                        
                        // Check if we're going out of bounds
                        if (x < 0 || x >= level.gridSize || y < 0 || y >= level.gridSize) {
                            path.push({ x, y, direction });
                            break;
                        }
                        
                        // Add current position to path
                        path.push({ x, y, direction });
                        
                        // Check for targets
                        const target = level.targets.find(t => t.x === x && t.y === y);
                        if (target) {
                            gameState.hitTargets.add(`${target.x},${target.y}`);
                        }
                        
                        // Check for objects
                        const obj = level.objects.find(o => o.x === x && o.y === y);
                        if (obj) {
                            switch(obj.type) {
                                case 'mirror-forward':
                                case 'mirror-backward':
                                    // Change direction based on mirror type
                                    direction = reflectLaser(direction, obj.type);
                                    break;
                                    
                                case 'splitter':
                                    // Split the beam into perpendicular directions
                                    if (direction === 'right' || direction === 'left') {
                                        queue.push({ x, y, direction: 'up', path: [...path] });
                                        queue.push({ x, y, direction: 'down', path: [...path] });
                                    } else {
                                        queue.push({ x, y, direction: 'left', path: [...path] });
                                        queue.push({ x, y, direction: 'right', path: [...path] });
                                    }
                                    // Stop following this path
                                    x = level.gridSize; // Force exit
                                    break;
                                    
                                case 'blocker':
                                    // Laser stops at blocker
                                    x = level.gridSize; // Force exit
                                    break;
                            }
                        }
                    }
                    
                    paths.push(path);
                }
                
                return paths;
            }

            // Reflect laser based on mirror type
            function reflectLaser(direction, mirrorType) {
                if (mirrorType === 'mirror-forward') {
                    switch (direction) {
                        case 'right': return 'up';
                        case 'left': return 'down';
                        case 'down': return 'left';
                        case 'up': return 'right';
                    }
                } else { // mirror-backward
                    switch (direction) {
                        case 'right': return 'down';
                        case 'left': return 'up';
                        case 'down': return 'right';
                        case 'up': return 'left';
                    }
                }
            }

            // Draw laser beam
            function drawLaserBeam(path) {
                const size = gameState.cellSize;
                
                ctx.strokeStyle = 'rgba(255, 50, 50, 0.7)';
                ctx.lineWidth = 3;
                ctx.setLineDash([]);
                
                for (let i = 0; i < path.length - 1; i++) {
                    const current = path[i];
                    const next = path[i + 1];
                    
                    const startX = current.x * size + size / 2;
                    const startY = current.y * size + size / 2;
                    const endX = next.x * size + size / 2;
                    const endY = next.y * size + size / 2;
                    
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    
                    // Draw laser glow
                    ctx.strokeStyle = 'rgba(255, 100, 100, 0.3)';
                    ctx.lineWidth = 8;
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    
                    // Reset for next segment
                    ctx.strokeStyle = 'rgba(255, 50, 50, 0.7)';
                    ctx.lineWidth = 3;
                }
            }

            // Check if all targets are hit
            function checkLevelComplete() {
                const level = gameState.levels[gameState.currentLevel - 1];
                return gameState.hitTargets.size === level.targets.length;
            }

            // Update display
            function updateDisplay() {
                const level = gameState.levels[gameState.currentLevel - 1];
                levelDisplay.textContent = gameState.currentLevel;
                levelTitle.textContent = `${gameState.currentLevel}: ${level.name}`;
                
                targetsDisplay.textContent = `${gameState.hitTargets.size}/${level.targets.length}`;
                movesDisplay.textContent = gameState.moves;
                
                // Update level indicator
                document.querySelectorAll('.level-dot').forEach((dot, index) => {
                    dot.classList.toggle('active', index + 1 === gameState.currentLevel);
                });
            }

            // Set up event listeners
            function setupEventListeners() {
                stepLaserBtn.addEventListener('click', function() {
                    calculateAndDrawLasers();
                });
                
                autoLaserBtn.addEventListener('click', function() {
                    gameState.autoLaser = !gameState.autoLaser;
                    autoLaserBtn.textContent = gameState.autoLaser ? 'AUTO LASER (ON)' : 'AUTO LASER (OFF)';
                    
                    if (gameState.autoLaser) {
                        calculateAndDrawLasers();
                    } else {
                        renderGame();
                        updateDisplay();
                    }
                });
                
                resetLevelBtn.addEventListener('click', function() {
                    gameState.moves = 0;
                    gameState.hitTargets.clear();
                    // Reset objects to original positions
                    const level = gameState.levels[gameState.currentLevel - 1];
                    level.objects.forEach(obj => {
                        if (obj.originalX !== undefined) {
                            obj.x = obj.originalX;
                            obj.y = obj.originalY;
                        }
                    });
                    renderGame();
                    if (gameState.autoLaser) {
                        calculateAndDrawLasers();
                    }
                    updateDisplay();
                });
                
                prevLevelBtn.addEventListener('click', function() {
                    if (gameState.currentLevel > 1) {
                        gameState.currentLevel--;
                        gameState.moves = 0;
                        gameState.hitTargets.clear();
                        setupCanvas();
                        renderGame();
                        levelComplete.classList.remove('show');
                        
                        if (gameState.autoLaser) {
                            calculateAndDrawLasers();
                        }
                        updateDisplay();
                    }
                });
                
                nextLevelBtn.addEventListener('click', function() {
                    if (gameState.currentLevel < gameState.levels.length) {
                        gameState.currentLevel++;
                        gameState.moves = 0;
                        gameState.hitTargets.clear();
                        setupCanvas();
                        renderGame();
                        levelComplete.classList.remove('show');
                        
                        if (gameState.autoLaser) {
                            calculateAndDrawLasers();
                        }
                        updateDisplay();
                    }
                });
                
                nextLevelCompleteBtn.addEventListener('click', function() {
                    if (gameState.currentLevel < gameState.levels.length) {
                        gameState.currentLevel++;
                        gameState.moves = 0;
                        gameState.hitTargets.clear();
                        setupCanvas();
                        renderGame();
                        levelComplete.classList.remove('show');
                        
                        if (gameState.autoLaser) {
                            calculateAndDrawLasers();
                        }
                    } else {
                        levelComplete.classList.remove('show');
                    }
                });
                
                playAgainBtn.addEventListener('click', function() {
                    gameState.moves = 0;
                    gameState.hitTargets.clear();
                    // Reset objects to original positions
                    const level = gameState.levels[gameState.currentLevel - 1];
                    level.objects.forEach(obj => {
                        if (obj.originalX !== undefined) {
                            obj.x = obj.originalX;
                            obj.y = obj.originalY;
                        }
                    });
                    renderGame();
                    levelComplete.classList.remove('show');
                    
                    if (gameState.autoLaser) {
                        calculateAndDrawLasers();
                    }
                    updateDisplay();
                });
                
                objectOptions.forEach(option => {
                    option.addEventListener('click', function() {
                        objectOptions.forEach(opt => opt.classList.remove('active'));
                        this.classList.add('active');
                        gameState.selectedObjectType = this.dataset.type;
                    });
                });
                
                // Handle window resize
                window.addEventListener('resize', function() {
                    setupCanvas();
                    renderGame();
                    if (gameState.autoLaser) {
                        calculateAndDrawLasers();
                    }
                });
                
                // Initialize original object positions
                gameState.levels.forEach(level => {
                    level.objects.forEach(obj => {
                        if (obj.movable) {
                            obj.originalX = obj.x;
                            obj.originalY = obj.y;
                        }
                    });
                });
                
                // Add drag and drop functionality for objects
                setupDragAndDrop();
            }

            // Set up drag and drop for objects
            function setupDragAndDrop() {
                let draggedObject = null;
                let dragOffsetX = 0;
                let dragOffsetY = 0;
                
                canvas.addEventListener('mousedown', handleMouseDown);
                canvas.addEventListener('mousemove', handleMouseMove);
                canvas.addEventListener('mouseup', handleMouseUp);
                canvas.addEventListener('contextmenu', handleRightClick);
                
                // Touch events for mobile
                canvas.addEventListener('touchstart', handleTouchStart);
                canvas.addEventListener('touchmove', handleTouchMove);
                canvas.addEventListener('touchend', handleTouchEnd);
                
                function handleMouseDown(e) {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    startDrag(x, y);
                }
                
                function handleMouseMove(e) {
                    if (!draggedObject) return;
                    
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    updateDrag(x, y);
                }
                
                function handleMouseUp() {
                    endDrag();
                }
                
                function handleRightClick(e) {
                    e.preventDefault();
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    rotateObject(x, y);
                }
                
                function handleTouchStart(e) {
                    e.preventDefault();
                    const rect = canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    
                    startDrag(x, y);
                }
                
                function handleTouchMove(e) {
                    e.preventDefault();
                    if (!draggedObject) return;
                    
                    const rect = canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    
                    updateDrag(x, y);
                }
                
                function handleTouchEnd() {
                    endDrag();
                }
                
                function startDrag(x, y) {
                    const level = gameState.levels[gameState.currentLevel - 1];
                    const cellSize = gameState.cellSize;
                    
                    // Find if an object was clicked
                    for (const obj of level.objects) {
                        if (!obj.movable) continue;
                        
                        const objX = obj.x * cellSize;
                        const objY = obj.y * cellSize;
                        
                        if (x >= objX && x < objX + cellSize &&
                            y >= objY && y < objY + cellSize) {
                            
                            draggedObject = obj;
                            dragOffsetX = x - objX;
                            dragOffsetY = y - objY;
                            break;
                        }
                    }
                }
                
                function updateDrag(x, y) {
                    if (!draggedObject) return;
                    
                    const cellSize = gameState.cellSize;
                    const level = gameState.levels[gameState.currentLevel - 1];
                    
                    // Calculate new cell position
                    const newX = Math.floor((x - dragOffsetX) / cellSize);
                    const newY = Math.floor((y - dragOffsetY) / cellSize);
                    
                    // Check if the new position is valid
                    if (newX >= 0 && newX < level.gridSize && 
                        newY >= 0 && newY < level.gridSize) {
                        
                        // Check if cell is empty (no target, laser, or other object)
                        const hasTarget = level.targets.some(t => t.x === newX && t.y === newY);
                        const hasLaser = level.lasers.some(l => l.x === newX && l.y === newY);
                        const hasOtherObject = level.objects.some(o => 
                            o !== draggedObject && o.x === newX && o.y === newY);
                        
                        if (!hasTarget && !hasLaser && !hasOtherObject) {
                            draggedObject.x = newX;
                            draggedObject.y = newY;
                            
                            // Update display
                            renderGame();
                            if (gameState.autoLaser) {
                                calculateAndDrawLasers();
                            }
                        }
                    }
                }
                
                function endDrag() {
                    if (draggedObject) {
                        gameState.moves++;
                        updateDisplay();
                        draggedObject = null;
                    }
                }
                
                function rotateObject(x, y) {
                    const level = gameState.levels[gameState.currentLevel - 1];
                    const cellSize = gameState.cellSize;
                    
                    // Find if an object was clicked
                    for (const obj of level.objects) {
                        if (!obj.movable) continue;
                        
                        const objX = obj.x * cellSize;
                        const objY = obj.y * cellSize;
                        
                        if (x >= objX && x < objX + cellSize &&
                            y >= objY && y < objY + cellSize) {
                            
                            // Rotate the object (for mirrors, swap types)
                            if (obj.type === 'mirror-forward') {
                                obj.type = 'mirror-backward';
                            } else if (obj.type === 'mirror-backward') {
                                obj.type = 'mirror-forward';
                            }
                            // For splitters, rotation doesn't change behavior
                            
                            gameState.moves++;
                            renderGame();
                            if (gameState.autoLaser) {
                                calculateAndDrawLasers();
                            }
                            updateDisplay();
                            break;
                        }
                    }
                }
            }

            // Start the game
            initGame();
        });
    </script>
</body>
</html>