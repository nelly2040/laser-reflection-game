<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laser Reflection Puzzle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            color: white;
        }
        
        .game-container {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            width: 100%;
            max-width: 900px;
            overflow: hidden;
        }
        
        .game-header {
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #00a8ff;
        }
        
        .game-title {
            font-size: 24px;
            font-weight: bold;
            color: #00a8ff;
            text-shadow: 0 0 10px rgba(0, 168, 255, 0.7);
        }
        
        .game-stats {
            display: flex;
            gap: 20px;
        }
        
        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #ffcc00;
        }
        
        .stat-label {
            font-size: 12px;
            color: #aaa;
        }
        
        .game-content {
            display: flex;
            padding: 20px;
            gap: 20px;
        }
        
        .game-board {
            flex: 1;
            background: rgba(30, 30, 60, 0.8);
            border-radius: 10px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .board-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .level-title {
            font-size: 20px;
            color: #ffcc00;
        }
        
        .objective {
            font-size: 14px;
            color: #aaa;
        }
        
        .board-container {
            position: relative;
            background: rgba(20, 20, 40, 0.9);
            border-radius: 8px;
            overflow: hidden;
            aspect-ratio: 1;
        }
        
        #game-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .game-controls {
            width: 250px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .control-panel {
            background: rgba(30, 30, 60, 0.8);
            border-radius: 10px;
            padding: 15px;
        }
        
        .panel-title {
            font-size: 18px;
            color: #00a8ff;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .mirror-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .mirror-option {
            flex: 1;
            padding: 10px;
            background: rgba(50, 50, 100, 0.8);
            border-radius: 5px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 24px;
            font-weight: bold;
        }
        
        .mirror-option:hover {
            background: rgba(70, 70, 120, 0.8);
        }
        
        .mirror-option.active {
            background: rgba(0, 168, 255, 0.5);
            box-shadow: 0 0 10px rgba(0, 168, 255, 0.7);
        }
        
        .instructions {
            font-size: 14px;
            line-height: 1.5;
            color: #ccc;
        }
        
        .instructions ul {
            padding-left: 20px;
            margin: 10px 0;
        }
        
        .instructions li {
            margin-bottom: 5px;
        }
        
        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }
        
        .btn-primary {
            background: #00a8ff;
            color: white;
        }
        
        .btn-primary:hover {
            background: #0090e0;
            box-shadow: 0 0 15px rgba(0, 168, 255, 0.7);
        }
        
        .btn-secondary {
            background: #ffcc00;
            color: #333;
        }
        
        .btn-secondary:hover {
            background: #e6b800;
            box-shadow: 0 0 15px rgba(255, 204, 0, 0.7);
        }
        
        .btn-reset {
            background: #ff3333;
            color: white;
        }
        
        .btn-reset:hover {
            background: #e60000;
            box-shadow: 0 0 15px rgba(255, 51, 51, 0.7);
        }
        
        .level-complete {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }
        
        .level-complete.show {
            opacity: 1;
            pointer-events: all;
        }
        
        .complete-message {
            font-size: 36px;
            color: #ffcc00;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(255, 204, 0, 0.7);
        }
        
        .complete-stats {
            font-size: 20px;
            margin-bottom: 30px;
            text-align: center;
        }
        
        .controls-row {
            display: flex;
            gap: 10px;
        }
        
        .drag-instruction {
            text-align: center;
            font-size: 14px;
            color: #ffcc00;
            margin-top: 10px;
        }
        
        .level-indicator {
            display: flex;
            justify-content: center;
            gap: 5px;
            margin-top: 10px;
        }
        
        .level-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
        }
        
        .level-dot.active {
            background: #ffcc00;
            box-shadow: 0 0 5px #ffcc00;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <div class="game-title">LASER REFLECTION PUZZLE</div>
            <div class="game-stats">
                <div class="stat">
                    <div class="stat-value" id="level-display">1</div>
                    <div class="stat-label">LEVEL</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="targets-display">0/0</div>
                    <div class="stat-label">TARGETS</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="moves-display">0</div>
                    <div class="stat-label">MOVES</div>
                </div>
            </div>
        </div>
        
        <div class="game-content">
            <div class="game-board">
                <div class="board-header">
                    <div class="level-title">Level <span id="level-title">1</span></div>
                    <div class="objective">Redirect the lasers to hit all targets</div>
                </div>
                
                <div class="board-container">
                    <canvas id="game-canvas"></canvas>
                    <div class="level-complete" id="level-complete">
                        <div class="complete-message">LEVEL COMPLETE!</div>
                        <div class="complete-stats">
                            <div>Targets hit: <span id="targets-hit">0</span>/<span id="targets-total">0</span></div>
                            <div>Moves used: <span id="moves-used">0</span></div>
                        </div>
                        <div class="controls-row">
                            <button class="btn btn-secondary" id="next-level">NEXT LEVEL</button>
                            <button class="btn btn-reset" id="play-again">PLAY AGAIN</button>
                        </div>
                    </div>
                </div>
                
                <div class="drag-instruction">Drag mirrors to change the laser path</div>
                <div class="level-indicator" id="level-indicator">
                    <!-- Level dots will be generated by JavaScript -->
                </div>
            </div>
            
            <div class="game-controls">
                <div class="control-panel">
                    <div class="panel-title">LASER CONTROL</div>
                    <button class="btn btn-primary" id="step-laser" style="width: 100%; margin-bottom: 10px;">FIRE LASER</button>
                    <button class="btn btn-secondary" id="auto-laser" style="width: 100%;">AUTO LASER (ON)</button>
                </div>
                
                <div class="control-panel">
                    <div class="panel-title">MIRROR TYPE</div>
                    <div class="mirror-selector">
                        <div class="mirror-option active" data-type="forward">
                            <div>/</div>
                            <div>Forward</div>
                        </div>
                        <div class="mirror-option" data-type="backward">
                            <div>\</div>
                            <div>Backward</div>
                        </div>
                    </div>
                    <div class="instructions">
                        <p><strong>How to Play:</strong></p>
                        <ul>
                            <li>Drag mirrors to empty cells</li>
                            <li>Click "FIRE LASER" to test your solution</li>
                            <li>With AUTO LASER ON, the laser updates automatically</li>
                            <li>Hit all targets to complete the level</li>
                            <li>Use as few moves as possible</li>
                        </ul>
                    </div>
                </div>
                
                <div class="control-panel">
                    <div class="panel-title">CONTROLS</div>
                    <button class="btn btn-secondary" id="reset-level" style="width: 100%; margin-bottom: 10px;">RESET LEVEL</button>
                    <div class="controls-row">
                        <button class="btn btn-secondary" id="prev-level">PREV</button>
                        <button class="btn btn-secondary" id="next-level-btn">NEXT</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Game state
            const gameState = {
                currentLevel: 1,
                levels: [
                    {
                        // Level 1 - Simple diagonal reflection
                        lasers: [{ x: 0, y: 0, direction: 'right' }],
                        targets: [{ x: 6, y: 6 }],
                        mirrors: [
                            { x: 3, y: 3, type: 'forward', movable: true }
                        ],
                        blockers: [],
                        gridSize: 7
                    },
                    {
                        // Level 2 - Two mirrors, two targets
                        lasers: [{ x: 0, y: 0, direction: 'right' }],
                        targets: [{ x: 6, y: 0 }, { x: 0, y: 6 }],
                        mirrors: [
                            { x: 3, y: 0, type: 'forward', movable: true },
                            { x: 0, y: 3, type: 'backward', movable: true }
                        ],
                        blockers: [],
                        gridSize: 7
                    },
                    {
                        // Level 3 - Multiple reflections with blockers
                        lasers: [{ x: 0, y: 0, direction: 'right' }],
                        targets: [{ x: 6, y: 6 }],
                        mirrors: [
                            { x: 3, y: 0, type: 'forward', movable: true },
                            { x: 6, y: 3, type: 'backward', movable: true }
                        ],
                        blockers: [
                            { x: 3, y: 3 }, { x: 4, y: 4 }
                        ],
                        gridSize: 7
                    },
                    {
                        // Level 4 - Two lasers, complex path
                        lasers: [
                            { x: 0, y: 0, direction: 'right' },
                            { x: 6, y: 6, direction: 'left' }
                        ],
                        targets: [{ x: 3, y: 3 }, { x: 0, y: 6 }, { x: 6, y: 0 }],
                        mirrors: [
                            { x: 3, y: 0, type: 'forward', movable: true },
                            { x: 0, y: 3, type: 'backward', movable: true },
                            { x: 6, y: 3, type: 'forward', movable: true },
                            { x: 3, y: 6, type: 'backward', movable: true }
                        ],
                        blockers: [
                            { x: 2, y: 2 }, { x: 4, y: 4 }
                        ],
                        gridSize: 7
                    },
                    {
                        // Level 5 - Multiple lasers with complex reflections
                        lasers: [
                            { x: 0, y: 0, direction: 'right' },
                            { x: 6, y: 0, direction: 'down' },
                            { x: 6, y: 6, direction: 'left' }
                        ],
                        targets: [{ x: 3, y: 3 }, { x: 0, y: 6 }, { x: 6, y: 3 }, { x: 3, y: 0 }],
                        mirrors: [
                            { x: 2, y: 2, type: 'forward', movable: true },
                            { x: 4, y: 2, type: 'backward', movable: true },
                            { x: 2, y: 4, type: 'backward', movable: true },
                            { x: 4, y: 4, type: 'forward', movable: true }
                        ],
                        blockers: [
                            { x: 1, y: 1 }, { x: 5, y: 1 }, { x: 1, y: 5 }, { x: 5, y: 5 }
                        ],
                        gridSize: 7
                    },
                    {
                        // Level 6 - Ultimate challenge with multiple lasers and targets
                        lasers: [
                            { x: 0, y: 0, direction: 'right' },
                            { x: 6, y: 0, direction: 'down' },
                            { x: 6, y: 6, direction: 'left' },
                            { x: 0, y: 6, direction: 'up' }
                        ],
                        targets: [
                            { x: 2, y: 2 }, { x: 4, y: 2 }, 
                            { x: 2, y: 4 }, { x: 4, y: 4 },
                            { x: 3, y: 3 }
                        ],
                        mirrors: [
                            { x: 1, y: 1, type: 'forward', movable: true },
                            { x: 5, y: 1, type: 'backward', movable: true },
                            { x: 1, y: 5, type: 'backward', movable: true },
                            { x: 5, y: 5, type: 'forward', movable: true },
                            { x: 3, y: 1, type: 'forward', movable: true },
                            { x: 3, y: 5, type: 'backward', movable: true }
                        ],
                        blockers: [
                            { x: 0, y: 3 }, { x: 6, y: 3 }, { x: 3, y: 0 }, { x: 3, y: 6 }
                        ],
                        gridSize: 7
                    }
                ],
                moves: 0,
                selectedMirrorType: 'forward',
                autoLaser: true,
                draggedMirror: null,
                cellSize: 0,
                hitTargets: new Set()
            };

            // DOM elements
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            const levelDisplay = document.getElementById('level-display');
            const targetsDisplay = document.getElementById('targets-display');
            const movesDisplay = document.getElementById('moves-display');
            const levelTitle = document.getElementById('level-title');
            const stepLaserBtn = document.getElementById('step-laser');
            const autoLaserBtn = document.getElementById('auto-laser');
            const resetLevelBtn = document.getElementById('reset-level');
            const prevLevelBtn = document.getElementById('prev-level');
            const nextLevelBtn = document.getElementById('next-level-btn');
            const levelComplete = document.getElementById('level-complete');
            const nextLevelCompleteBtn = document.getElementById('next-level');
            const playAgainBtn = document.getElementById('play-again');
            const targetsHit = document.getElementById('targets-hit');
            const targetsTotal = document.getElementById('targets-total');
            const movesUsed = document.getElementById('moves-used');
            const mirrorOptions = document.querySelectorAll('.mirror-option');
            const levelIndicator = document.getElementById('level-indicator');

            // Initialize the game
            function initGame() {
                setupCanvas();
                createLevelIndicator();
                setupEventListeners();
                renderGame();
                if (gameState.autoLaser) {
                    calculateAndDrawLasers();
                }
                updateDisplay();
            }

            // Set up canvas
            function setupCanvas() {
                const container = document.querySelector('.board-container');
                const size = Math.min(container.clientWidth, container.clientHeight);
                canvas.width = size;
                canvas.height = size;
                gameState.cellSize = size / gameState.levels[gameState.currentLevel - 1].gridSize;
            }

            // Create level indicator dots
            function createLevelIndicator() {
                levelIndicator.innerHTML = '';
                for (let i = 0; i < gameState.levels.length; i++) {
                    const dot = document.createElement('div');
                    dot.className = `level-dot ${i + 1 === gameState.currentLevel ? 'active' : ''}`;
                    dot.addEventListener('click', () => {
                        gameState.currentLevel = i + 1;
                        gameState.moves = 0;
                        gameState.hitTargets.clear();
                        setupCanvas();
                        renderGame();
                        if (gameState.autoLaser) {
                            calculateAndDrawLasers();
                        }
                        updateDisplay();
                    });
                    levelIndicator.appendChild(dot);
                }
            }

            // Render the game
            function renderGame() {
                const level = gameState.levels[gameState.currentLevel - 1];
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw grid
                drawGrid();
                
                // Draw blockers
                drawBlockers();
                
                // Draw targets
                drawTargets();
                
                // Draw mirrors
                drawMirrors();
                
                // Draw lasers
                drawLasers();
            }

            // Draw grid
            function drawGrid() {
                const level = gameState.levels[gameState.currentLevel - 1];
                const size = gameState.cellSize;
                
                ctx.strokeStyle = 'rgba(100, 100, 150, 0.5)';
                ctx.lineWidth = 1;
                
                for (let i = 0; i <= level.gridSize; i++) {
                    // Vertical lines
                    ctx.beginPath();
                    ctx.moveTo(i * size, 0);
                    ctx.lineTo(i * size, canvas.height);
                    ctx.stroke();
                    
                    // Horizontal lines
                    ctx.beginPath();
                    ctx.moveTo(0, i * size);
                    ctx.lineTo(canvas.width, i * size);
                    ctx.stroke();
                }
            }

            // Draw blockers
            function drawBlockers() {
                const level = gameState.levels[gameState.currentLevel - 1];
                const size = gameState.cellSize;
                
                ctx.fillStyle = 'rgba(80, 80, 120, 0.9)';
                ctx.strokeStyle = 'rgba(60, 60, 100, 0.9)';
                ctx.lineWidth = 2;
                
                level.blockers.forEach(blocker => {
                    ctx.fillRect(blocker.x * size, blocker.y * size, size, size);
                    ctx.strokeRect(blocker.x * size, blocker.y * size, size, size);
                    
                    // Draw X mark
                    ctx.strokeStyle = 'rgba(40, 40, 80, 0.9)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(blocker.x * size + 5, blocker.y * size + 5);
                    ctx.lineTo((blocker.x + 1) * size - 5, (blocker.y + 1) * size - 5);
                    ctx.moveTo((blocker.x + 1) * size - 5, blocker.y * size + 5);
                    ctx.lineTo(blocker.x * size + 5, (blocker.y + 1) * size - 5);
                    ctx.stroke();
                });
            }

            // Draw targets
            function drawTargets() {
                const level = gameState.levels[gameState.currentLevel - 1];
                const size = gameState.cellSize;
                
                level.targets.forEach(target => {
                    const centerX = target.x * size + size / 2;
                    const centerY = target.y * size + size / 2;
                    const radius = size / 3;
                    
                    // Check if target is hit
                    const isHit = gameState.hitTargets.has(`${target.x},${target.y}`);
                    
                    // Target circle
                    const gradient = ctx.createRadialGradient(
                        centerX, centerY, radius / 2,
                        centerX, centerY, radius
                    );
                    
                    if (isHit) {
                        gradient.addColorStop(0, '#33ff33');
                        gradient.addColorStop(1, '#009900');
                    } else {
                        gradient.addColorStop(0, '#ff33aa');
                        gradient.addColorStop(1, '#aa0077');
                    }
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Target outline
                    ctx.strokeStyle = isHit ? '#00ff00' : '#ff00aa';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Target letter
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold ' + (size / 3) + 'px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('T', centerX, centerY);
                });
            }

            // Draw mirrors
            function drawMirrors() {
                const level = gameState.levels[gameState.currentLevel - 1];
                const size = gameState.cellSize;
                
                level.mirrors.forEach(mirror => {
                    const x = mirror.x * size;
                    const y = mirror.y * size;
                    
                    // Mirror background
                    ctx.fillStyle = mirror.movable ? 'rgba(100, 150, 255, 0.7)' : 'rgba(150, 100, 255, 0.7)';
                    ctx.fillRect(x, y, size, size);
                    
                    // Mirror border
                    ctx.strokeStyle = mirror.movable ? 'rgba(80, 130, 255, 0.9)' : 'rgba(130, 80, 255, 0.9)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, size, size);
                    
                    // Draw diagonal line for mirror
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    
                    if (mirror.type === 'forward') {
                        // Forward slash (/)
                        ctx.moveTo(x + size - 5, y + 5);
                        ctx.lineTo(x + 5, y + size - 5);
                    } else {
                        // Backward slash (\)
                        ctx.moveTo(x + 5, y + 5);
                        ctx.lineTo(x + size - 5, y + size - 5);
                    }
                    
                    ctx.stroke();
                });
            }

            // Draw lasers
            function drawLasers() {
                const level = gameState.levels[gameState.currentLevel - 1];
                const size = gameState.cellSize;
                
                level.lasers.forEach(laser => {
                    const x = laser.x * size + size / 2;
                    const y = laser.y * size + size / 2;
                    
                    // Laser source
                    const gradient = ctx.createRadialGradient(x, y, size / 8, x, y, size / 3);
                    gradient.addColorStop(0, '#ff6600');
                    gradient.addColorStop(1, '#ff3300');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, size / 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Laser direction indicator
                    ctx.fillStyle = '#ff9900';
                    ctx.font = 'bold ' + (size / 4) + 'px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(laser.direction.toUpperCase(), x, y);
                });
            }

            // Calculate and draw laser paths
            function calculateAndDrawLasers() {
                const level = gameState.levels[gameState.currentLevel - 1];
                
                // Clear previous laser beams and hit targets
                gameState.hitTargets.clear();
                renderGame();
                
                // Calculate and draw each laser path
                level.lasers.forEach(laser => {
                    const path = calculateLaserPath(laser);
                    drawLaserBeam(path);
                });
                
                // Check if level is complete
                if (checkLevelComplete()) {
                    targetsHit.textContent = gameState.hitTargets.size;
                    targetsTotal.textContent = level.targets.length;
                    movesUsed.textContent = gameState.moves;
                    levelComplete.classList.add('show');
                }
                
                updateDisplay();
            }

            // Calculate laser path
            function calculateLaserPath(laser) {
                const level = gameState.levels[gameState.currentLevel - 1];
                const path = [];
                let x = laser.x;
                let y = laser.y;
                let direction = laser.direction;
                
                // Add starting point
                path.push({ x, y, direction });
                
                // Follow the laser path
                while (x >= 0 && x < level.gridSize && y >= 0 && y < level.gridSize) {
                    // Move to next cell
                    switch (direction) {
                        case 'right': x++; break;
                        case 'left': x--; break;
                        case 'down': y++; break;
                        case 'up': y--; break;
                    }
                    
                    // Check if we're going out of bounds
                    if (x < 0 || x >= level.gridSize || y < 0 || y >= level.gridSize) {
                        path.push({ x, y, direction });
                        break;
                    }
                    
                    // Add current position to path
                    path.push({ x, y, direction });
                    
                    // Check for targets
                    const target = level.targets.find(t => t.x === x && t.y === y);
                    if (target) {
                        gameState.hitTargets.add(`${target.x},${target.y}`);
                    }
                    
                    // Check for blockers
                    const blocker = level.blockers.find(b => b.x === x && b.y === y);
                    if (blocker) {
                        break; // Laser stops at blocker
                    }
                    
                    // Check for mirrors
                    const mirror = level.mirrors.find(m => m.x === x && m.y === y);
                    if (mirror) {
                        // Change direction based on mirror type
                        direction = reflectLaser(direction, mirror.type);
                    }
                }
                
                return path;
            }

            // Reflect laser based on mirror type
            function reflectLaser(direction, mirrorType) {
                if (mirrorType === 'forward') {
                    switch (direction) {
                        case 'right': return 'up';
                        case 'left': return 'down';
                        case 'down': return 'left';
                        case 'up': return 'right';
                    }
                } else { // backward mirror
                    switch (direction) {
                        case 'right': return 'down';
                        case 'left': return 'up';
                        case 'down': return 'right';
                        case 'up': return 'left';
                    }
                }
            }

            // Draw laser beam
            function drawLaserBeam(path) {
                const size = gameState.cellSize;
                
                ctx.strokeStyle = 'rgba(255, 50, 50, 0.7)';
                ctx.lineWidth = 3;
                ctx.setLineDash([]);
                
                for (let i = 0; i < path.length - 1; i++) {
                    const current = path[i];
                    const next = path[i + 1];
                    
                    const startX = current.x * size + size / 2;
                    const startY = current.y * size + size / 2;
                    const endX = next.x * size + size / 2;
                    const endY = next.y * size + size / 2;
                    
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    
                    // Draw laser glow
                    ctx.strokeStyle = 'rgba(255, 100, 100, 0.3)';
                    ctx.lineWidth = 8;
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    
                    // Reset for next segment
                    ctx.strokeStyle = 'rgba(255, 50, 50, 0.7)';
                    ctx.lineWidth = 3;
                }
            }

            // Check if all targets are hit
            function checkLevelComplete() {
                const level = gameState.levels[gameState.currentLevel - 1];
                return gameState.hitTargets.size === level.targets.length;
            }

            // Update display
            function updateDisplay() {
                const level = gameState.levels[gameState.currentLevel - 1];
                levelDisplay.textContent = gameState.currentLevel;
                levelTitle.textContent = gameState.currentLevel;
                
                targetsDisplay.textContent = `${gameState.hitTargets.size}/${level.targets.length}`;
                movesDisplay.textContent = gameState.moves;
                
                // Update level indicator
                document.querySelectorAll('.level-dot').forEach((dot, index) => {
                    dot.classList.toggle('active', index + 1 === gameState.currentLevel);
                });
            }

            // Set up event listeners
            function setupEventListeners() {
                stepLaserBtn.addEventListener('click', function() {
                    calculateAndDrawLasers();
                });
                
                autoLaserBtn.addEventListener('click', function() {
                    gameState.autoLaser = !gameState.autoLaser;
                    autoLaserBtn.textContent = gameState.autoLaser ? 'AUTO LASER (ON)' : 'AUTO LASER (OFF)';
                    
                    if (gameState.autoLaser) {
                        calculateAndDrawLasers();
                    } else {
                        renderGame();
                        updateDisplay();
                    }
                });
                
                resetLevelBtn.addEventListener('click', function() {
                    gameState.moves = 0;
                    gameState.hitTargets.clear();
                    // Reset mirrors to original positions
                    const level = gameState.levels[gameState.currentLevel - 1];
                    level.mirrors.forEach(mirror => {
                        if (mirror.originalX !== undefined) {
                            mirror.x = mirror.originalX;
                            mirror.y = mirror.originalY;
                        }
                    });
                    renderGame();
                    if (gameState.autoLaser) {
                        calculateAndDrawLasers();
                    }
                    updateDisplay();
                });
                
                prevLevelBtn.addEventListener('click', function() {
                    if (gameState.currentLevel > 1) {
                        gameState.currentLevel--;
                        gameState.moves = 0;
                        gameState.hitTargets.clear();
                        setupCanvas();
                        renderGame();
                        levelComplete.classList.remove('show');
                        
                        if (gameState.autoLaser) {
                            calculateAndDrawLasers();
                        }
                        updateDisplay();
                    }
                });
                
                nextLevelBtn.addEventListener('click', function() {
                    if (gameState.currentLevel < gameState.levels.length) {
                        gameState.currentLevel++;
                        gameState.moves = 0;
                        gameState.hitTargets.clear();
                        setupCanvas();
                        renderGame();
                        levelComplete.classList.remove('show');
                        
                        if (gameState.autoLaser) {
                            calculateAndDrawLasers();
                        }
                        updateDisplay();
                    }
                });
                
                nextLevelCompleteBtn.addEventListener('click', function() {
                    if (gameState.currentLevel < gameState.levels.length) {
                        gameState.currentLevel++;
                        gameState.moves = 0;
                        gameState.hitTargets.clear();
                        setupCanvas();
                        renderGame();
                        levelComplete.classList.remove('show');
                        
                        if (gameState.autoLaser) {
                            calculateAndDrawLasers();
                        }
                    } else {
                        levelComplete.classList.remove('show');
                    }
                });
                
                playAgainBtn.addEventListener('click', function() {
                    gameState.moves = 0;
                    gameState.hitTargets.clear();
                    // Reset mirrors to original positions
                    const level = gameState.levels[gameState.currentLevel - 1];
                    level.mirrors.forEach(mirror => {
                        if (mirror.originalX !== undefined) {
                            mirror.x = mirror.originalX;
                            mirror.y = mirror.originalY;
                        }
                    });
                    renderGame();
                    levelComplete.classList.remove('show');
                    
                    if (gameState.autoLaser) {
                        calculateAndDrawLasers();
                    }
                    updateDisplay();
                });
                
                mirrorOptions.forEach(option => {
                    option.addEventListener('click', function() {
                        mirrorOptions.forEach(opt => opt.classList.remove('active'));
                        this.classList.add('active');
                        gameState.selectedMirrorType = this.dataset.type;
                    });
                });
                
                // Handle window resize
                window.addEventListener('resize', function() {
                    setupCanvas();
                    renderGame();
                    if (gameState.autoLaser) {
                        calculateAndDrawLasers();
                    }
                });
                
                // Initialize original mirror positions
                gameState.levels.forEach(level => {
                    level.mirrors.forEach(mirror => {
                        if (mirror.movable) {
                            mirror.originalX = mirror.x;
                            mirror.originalY = mirror.y;
                        }
                    });
                });
                
                // Add drag and drop functionality for mirrors
                setupDragAndDrop();
            }

            // Set up drag and drop for mirrors
            function setupDragAndDrop() {
                let draggedMirror = null;
                let dragOffsetX = 0;
                let dragOffsetY = 0;
                
                canvas.addEventListener('mousedown', handleMouseDown);
                canvas.addEventListener('mousemove', handleMouseMove);
                canvas.addEventListener('mouseup', handleMouseUp);
                
                // Touch events for mobile
                canvas.addEventListener('touchstart', handleTouchStart);
                canvas.addEventListener('touchmove', handleTouchMove);
                canvas.addEventListener('touchend', handleTouchEnd);
                
                function handleMouseDown(e) {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    startDrag(x, y);
                }
                
                function handleMouseMove(e) {
                    if (!draggedMirror) return;
                    
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    updateDrag(x, y);
                }
                
                function handleMouseUp() {
                    endDrag();
                }
                
                function handleTouchStart(e) {
                    e.preventDefault();
                    const rect = canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    
                    startDrag(x, y);
                }
                
                function handleTouchMove(e) {
                    e.preventDefault();
                    if (!draggedMirror) return;
                    
                    const rect = canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    
                    updateDrag(x, y);
                }
                
                function handleTouchEnd() {
                    endDrag();
                }
                
                function startDrag(x, y) {
                    const level = gameState.levels[gameState.currentLevel - 1];
                    const cellSize = gameState.cellSize;
                    
                    // Find if a mirror was clicked
                    for (const mirror of level.mirrors) {
                        if (!mirror.movable) continue;
                        
                        const mirrorX = mirror.x * cellSize;
                        const mirrorY = mirror.y * cellSize;
                        
                        if (x >= mirrorX && x < mirrorX + cellSize &&
                            y >= mirrorY && y < mirrorY + cellSize) {
                            
                            draggedMirror = mirror;
                            dragOffsetX = x - mirrorX;
                            dragOffsetY = y - mirrorY;
                            break;
                        }
                    }
                }
                
                function updateDrag(x, y) {
                    if (!draggedMirror) return;
                    
                    const cellSize = gameState.cellSize;
                    const level = gameState.levels[gameState.currentLevel - 1];
                    
                    // Calculate new cell position
                    const newX = Math.floor((x - dragOffsetX) / cellSize);
                    const newY = Math.floor((y - dragOffsetY) / cellSize);
                    
                    // Check if the new position is valid
                    if (newX >= 0 && newX < level.gridSize && 
                        newY >= 0 && newY < level.gridSize) {
                        
                        // Check if cell is empty (no blocker, target, or other mirror)
                        const hasBlocker = level.blockers.some(b => b.x === newX && b.y === newY);
                        const hasTarget = level.targets.some(t => t.x === newX && t.y === newY);
                        const hasOtherMirror = level.mirrors.some(m => 
                            m !== draggedMirror && m.x === newX && m.y === newY);
                        
                        if (!hasBlocker && !hasTarget && !hasOtherMirror) {
                            draggedMirror.x = newX;
                            draggedMirror.y = newY;
                            
                            // Update display
                            renderGame();
                            if (gameState.autoLaser) {
                                calculateAndDrawLasers();
                            }
                        }
                    }
                }
                
                function endDrag() {
                    if (draggedMirror) {
                        gameState.moves++;
                        updateDisplay();
                        draggedMirror = null;
                    }
                }
            }

            // Start the game
            initGame();
        });
    </script>
</body>
</html>